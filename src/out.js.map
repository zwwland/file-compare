{
  "version": 3,
  "sources": ["../src/dtypes.js", "../src/utils.js", "../src/matrix.utils.js", "../src/nw.algorithm.js", "../src/sw.algorithm.js", "../src/traceback.utils.js", "../src/traceback.js", "../src/aligner.factory.js", "../src/index.js"],
  "sourcesContent": ["const directions = Object.freeze({\n    NONE: 0,\n    DIAGONAL: 1,\n    LEFT: 2,\n    TOP: 3,\n});\n\n// Data type for traced back, scoring matrix, cel scores.\n// Stores a score value and a traceback direction.\nconst TracedScore = (score, direction = directions.NONE) => {\n    if (Object.values(directions).includes(direction)) {\n        return { score, direction };\n    }\n    throw TypeError('Invalid direction value for TracedScore');\n};\n\nmodule.exports = {\n    TracedScore,\n    directions,\n};\n", "const { TracedScore } = require('./dtypes');\n\nconst pipe = (...fns) =>\n    fns.reduce(\n        (prev, curr) => (x) => curr(prev(x)),\n        (x) => x,\n    );\n\nconst reverse = (x) => -x;\n\nconst nanException = () => {\n    throw TypeError('Non number input to decreaseAndRectify().');\n};\n\nconst throwIfNotNumber = (x) => (Number.isNaN(Number(x)) ? nanException() : x);\n\nconst scoreReducer = (max, score) => {\n    if (Number.isInteger(score.score)) {\n        return score.score > max.score ? score : max;\n    }\n    throw TypeError(`Score object as an invalid score property: ${score.score}.`);\n};\n\nconst reduceTracedScores = (scores, defaultScore) =>\n    scores.reduce(scoreReducer, TracedScore(defaultScore));\n\nmodule.exports = {\n    reverse: pipe(throwIfNotNumber, reverse),\n    reduceTracedScores,\n};\n", "const { directions } = require('./dtypes');\n\n// Creates a matrix of the specified width and length.\n// First row and column are filled with a negative integer progression starting\n// from 0 ar coordinates (0, 0). The remaining cells are filled with zeros.\nconst initNWScoringMatrix = ({ width, heigth }) => {\n    const matrix = [];\n    for (let row = 0; row < heigth; row += 1) {\n        if (row === 0) {\n            matrix[row] = Array(width)\n                .fill()\n                .map((_, i) => -i || 0);\n        } else {\n            matrix[row] = Array(width).fill(0);\n            matrix[row][0] = -row;\n        }\n    }\n    return matrix;\n};\n\n// Creates a matrix of the specified width and length.\n// The top row buffer is filled with the value for directions.LEFT.\n// The left column buffer is filled with the value for directions.TOP.\n// The top-left corner cell is filled with the value for directions.NONE.\nconst initNWTracebacMatrix = ({ width, heigth }) => {\n    const matrix = [];\n    for (let row = 0; row < heigth; row += 1) {\n        if (row === 0) {\n            matrix[row] = Array(width).fill(directions.LEFT);\n        } else {\n            matrix[row] = Array(width).fill(directions.NONE);\n            matrix[row][0] = directions.TOP;\n        }\n        matrix[0][0] = directions.NONE;\n    }\n    return matrix;\n};\n\n// Creates a matrix filled with the supplied value of the specified width and\n// length.\nconst createMatrix = ({ width, heigth, fill = 0 }) =>\n    Array(heigth)\n        .fill(fill)\n        .map(() => Array(width).fill(fill));\n\n// Returns the left portion of the row specified by the supplied coordinates.\nconst extractRow = ({ matrix, row, col }) => matrix[row].slice(0, col + 1);\n\n// Return the top portion of the column specified by the supplied coordinates.\nconst extractColumn = ({ matrix, row, col }) =>\n    matrix\n        .slice(0, row + 1)\n        .map((_row) => _row.slice(col, col + 1))\n        .reduce((prev, curr) => [...prev, ...curr], []);\n\nmodule.exports = {\n    createMatrix,\n    extractColumn,\n    extractRow,\n    initNWScoringMatrix,\n    initNWTracebacMatrix,\n};\n", "const { initNWScoringMatrix, initNWTracebacMatrix } = require('./matrix.utils');\nconst { reduceTracedScores } = require('./utils');\nconst { TracedScore, directions } = require('./dtypes');\n\nfunction needlemanWunsch({ sequence1, sequence2, gapScoreFunction, similarityScoreFunction }) {\n    // Initialize matrices for dynamic programming solution.\n    const heigth = sequence1.length + 1;\n    const width = sequence2.length + 1;\n    const scoringMatrix = initNWScoringMatrix({ width, heigth });\n    const tracebackMatrix = initNWTracebacMatrix({ width, heigth });\n\n    let lastScore = 0;\n    let lastCoordinates = [0, 0];\n\n    // Fill the matrices.\n    for (let row = 1; row < heigth; row += 1) {\n        for (let col = 1; col < width; col += 1) {\n            // Simlarity score of the current couple of characters in the\n            // input sequences. Subtracts 1 from matrix coordinates to account\n            // for the matrix buffer.\n            const similarityScore = similarityScoreFunction(sequence1[row - 1], sequence2[col - 1]);\n\n            // Candidate scores to fill the current matrix cell.\n            const scores = [\n                TracedScore(scoringMatrix[row - 1][col] + gapScoreFunction(), directions.TOP),\n                TracedScore(scoringMatrix[row][col - 1] + gapScoreFunction(), directions.LEFT),\n                TracedScore(scoringMatrix[row - 1][col - 1] + similarityScore, directions.DIAGONAL),\n            ];\n\n            // Select highest scoring substitution and fill the matrices.\n            const { score: cellScore, direction } = reduceTracedScores(scores, -Infinity);\n            scoringMatrix[row][col] = cellScore;\n            tracebackMatrix[row][col] = direction;\n            lastScore = cellScore;\n            lastCoordinates = [row, col];\n        }\n    }\n\n    return {\n        alignmentScore: lastScore,\n        scoringMatrix,\n        tracebackMatrix,\n        tracebackStart: lastCoordinates,\n    };\n}\n\nmodule.exports = needlemanWunsch;\n", "const { createMatrix, extractColumn, extractRow } = require('./matrix.utils');\nconst { reduceTracedScores } = require('./utils');\nconst { TracedScore, directions } = require('./dtypes');\n\n// Takes a portion of scoring matrix (left-row or top-column) and computes the\n// length of a gap if the gap is opened at that position.\n// Returns the maximum score in the sequence and the maximum gap length.\nfunction computeGapLength(sequence) {\n    let max = -1;\n    let gapLength = 0;\n    for (let cursor = 1; cursor < sequence.length; cursor += 1) {\n        if (sequence[cursor] > max) {\n            max = sequence[cursor];\n            gapLength = cursor;\n        }\n    }\n    return { max, gapLength };\n}\n\n// Compute candidate scores to fill a certain cell of the scoring matrix.\n// Returns a list of score objects storing score value and traceback direction.\nfunction computeScores({ scoringMatrix, row, col, gapScoreFunction, similarityScore }) {\n    // Get left-row and top-column from the current coordinates.\n    const leftSequence = extractRow({ matrix: scoringMatrix, row, col });\n    const topSequence = extractColumn({ matrix: scoringMatrix, row, col });\n\n    // Compute left and top maximum values and gap lengths.\n    const { max: leftMax, gapLength: leftGapLength } = computeGapLength(leftSequence.reverse());\n    const { max: topMax, gapLength: topGapLength } = computeGapLength(topSequence.reverse());\n\n    // Compute scores for every type of sustitution for the current\n    // coordinates. In the scores array are computed in order:\n    //   - Deletion score.\n    //   - Insertion score.\n    //   - Mutation score.\n    return [\n        TracedScore(topMax + gapScoreFunction(topGapLength), directions.TOP),\n        TracedScore(leftMax + gapScoreFunction(leftGapLength), directions.LEFT),\n        TracedScore(scoringMatrix[row - 1][col - 1] + similarityScore, directions.DIAGONAL),\n    ];\n}\n\nfunction smithWaterman({ sequence1, sequence2, gapScoreFunction, similarityScoreFunction }) {\n    // Initialize matrices for dynamic programming solution.\n    const heigth = sequence1.length + 1;\n    const width = sequence2.length + 1;\n    const scoringMatrix = createMatrix({ width, heigth });\n    const tracebackMatrix = createMatrix({ width, heigth, fill: directions.NONE });\n\n    let highestScore = 0;\n    let highestScoreCoordinates = [0, 0];\n\n    // Fill the matrices.\n    for (let row = 1; row < heigth; row += 1) {\n        for (let col = 1; col < width; col += 1) {\n            // Simlarity score of the current couple of characters in the\n            // input sequences. Subtracts 1 from matrix coordinates to account\n            // for the matrix buffer.\n            const similarityScore = similarityScoreFunction(sequence1[row - 1], sequence2[col - 1]);\n\n            // Candidate scores to fill the current matrix cell.\n            const scores = computeScores({\n                scoringMatrix,\n                row,\n                col,\n                gapScoreFunction,\n                similarityScore,\n            });\n\n            // Select highest scoring substitution and fill the matrices.\n            const { score: bestScore, direction } = reduceTracedScores(scores, 0);\n            scoringMatrix[row][col] = bestScore;\n            tracebackMatrix[row][col] = direction;\n\n            // Keep record of the highest score in the scoring matrix.\n            if (bestScore >= highestScore) {\n                highestScore = bestScore;\n                highestScoreCoordinates = [row, col];\n            }\n        }\n    }\n\n    return {\n        alignmentScore: highestScore,\n        scoringMatrix,\n        tracebackMatrix,\n        tracebackStart: highestScoreCoordinates,\n    };\n}\n\nmodule.exports = smithWaterman;\n", "const { directions } = require('./dtypes');\n\nconst alignmentUpdaters = (gapSymbol) => (direction) => {\n    const updaters = {\n        [directions.DIAGONAL]: ({ seq1, seq2, row, col }) => [seq1[row - 1], seq2[col - 1]],\n        [directions.LEFT]: ({ seq2, col }) => [gapSymbol, seq2[col - 1]],\n        [directions.TOP]: ({ seq1, row }) => [seq1[row - 1], gapSymbol],\n    };\n    return updaters[direction];\n};\n\nconst coordinateUpdaters = (direction) => {\n    const getters = {\n        [directions.DIAGONAL]: ([row, col]) => [row - 1, col - 1],\n        [directions.LEFT]: ([row, col]) => [row, col - 1],\n        [directions.TOP]: ([row, col]) => [row - 1, col],\n    };\n    return getters[direction];\n};\n\nmodule.exports = {\n    alignmentUpdaters,\n    coordinateUpdaters,\n};\n", "const { alignmentUpdaters, coordinateUpdaters } = require('./traceback.utils');\nconst { directions } = require('./dtypes');\n\nfunction traceback({ sequence1, sequence2, tracebackMatrix, tracebackStart, gapSymbol }) {\n    let [row, col] = tracebackStart;\n    const aligned1 = [];\n    const aligned2 = [];\n    const coordinateWalk = [[row, col]];\n    const updaters = alignmentUpdaters(gapSymbol);\n    while (tracebackMatrix[row][col] !== directions.NONE) {\n        const direction = tracebackMatrix[row][col];\n        const alignmentUpdater = updaters(direction);\n        const [char1, char2] = alignmentUpdater({ seq1: sequence1, seq2: sequence2, row, col });\n        aligned1.unshift(char1);\n        aligned2.unshift(char2);\n        const coordinateUpdater = coordinateUpdaters(direction);\n        [row, col] = coordinateUpdater([row, col]);\n        coordinateWalk.push([row, col]);\n    }\n    return {\n        alignedSequence1: aligned1.join(''),\n        alignedSequence2: aligned2.join(''),\n        coordinateWalk,\n    };\n}\n\nmodule.exports = traceback;\n", "const { directions } = require('./dtypes');\nconst traceback = require('./traceback');\n\nconst AlignerFactory = ({\n    algorithm,\n    similarityScoreFunctionDefault,\n    gapScoreFunctionDefault,\n    gapSymbolDefault,\n}) => ({\n    similarityScoreFunction = similarityScoreFunctionDefault,\n    gapScoreFunction = gapScoreFunctionDefault,\n    gapSymbol = gapSymbolDefault,\n} = {}) => ({\n    similarityScoreFunction,\n    gapScoreFunction,\n    gapSymbol,\n    directions,\n    align(sequence1 = '', sequence2 = '') {\n        const { alignmentScore, scoringMatrix, tracebackMatrix, tracebackStart } = algorithm({\n            sequence1,\n            sequence2,\n            gapScoreFunction: this.gapScoreFunction,\n            similarityScoreFunction: this.similarityScoreFunction,\n        });\n        const { alignedSequence1, alignedSequence2, coordinateWalk } = traceback({\n            sequence1,\n            sequence2,\n            tracebackMatrix,\n            tracebackStart,\n            gapSymbol: this.gapSymbol,\n        });\n        return {\n            score: alignmentScore,\n            originalSequences: [sequence1, sequence2],\n            alignedSequences: [alignedSequence1, alignedSequence2],\n            coordinateWalk,\n            scoringMatrix,\n            tracebackMatrix,\n            alignment: `${alignedSequence1}\\n${alignedSequence2}`,\n        };\n    },\n});\n\nmodule.exports = AlignerFactory;\n", "const { reverse } = require('./utils');\n\nconst nwAlgorithm = require('./nw.algorithm');\nconst swAlgorithm = require('./sw.algorithm');\nconst AlignerFactory = require('./aligner.factory');\n\nmodule.exports = {\n    NWaligner: AlignerFactory({\n        algorithm: nwAlgorithm,\n        similarityScoreFunctionDefault: (char1, char2) => (char1 === char2 ? 1 : -2),\n        gapScoreFunctionDefault: () => -1,\n        gapSymbolDefault: '-',\n    }),\n    SWaligner: AlignerFactory({\n        algorithm: swAlgorithm,\n        similarityScoreFunctionDefault: (char1, char2) => (char1 === char2 ? 2 : -1),\n        gapScoreFunctionDefault: reverse,\n        gapSymbolDefault: '-',\n    }),\n};\n"],
  "mappings": ";;;;;;AAAA;AAAA;AAAA,QAAM,aAAa,OAAO,OAAO;AAAA,MAC7B,MAAM;AAAA,MACN,UAAU;AAAA,MACV,MAAM;AAAA,MACN,KAAK;AAAA,IACT,CAAC;AAID,QAAM,cAAc,CAAC,OAAO,YAAY,WAAW,SAAS;AACxD,UAAI,OAAO,OAAO,UAAU,EAAE,SAAS,SAAS,GAAG;AAC/C,eAAO,EAAE,OAAO,UAAU;AAAA,MAC9B;AACA,YAAM,UAAU,yCAAyC;AAAA,IAC7D;AAEA,WAAO,UAAU;AAAA,MACb;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;ACnBA;AAAA;AAAA,QAAM,EAAE,gBAAgB;AAExB,QAAM,OAAO,IAAI,QACb,IAAI,OACA,CAAC,MAAM,SAAS,CAAC,MAAM,KAAK,KAAK,CAAC,CAAC,GACnC,CAAC,MAAM,CACX;AAEJ,QAAM,UAAU,CAAC,MAAM,CAAC;AAExB,QAAM,eAAe,MAAM;AACvB,YAAM,UAAU,2CAA2C;AAAA,IAC/D;AAEA,QAAM,mBAAmB,CAAC,MAAO,OAAO,MAAM,OAAO,CAAC,CAAC,IAAI,aAAa,IAAI;AAE5E,QAAM,eAAe,CAAC,KAAK,UAAU;AACjC,UAAI,OAAO,UAAU,MAAM,KAAK,GAAG;AAC/B,eAAO,MAAM,QAAQ,IAAI,QAAQ,QAAQ;AAAA,MAC7C;AACA,YAAM,UAAU,8CAA8C,MAAM,QAAQ;AAAA,IAChF;AAEA,QAAM,qBAAqB,CAAC,QAAQ,iBAChC,OAAO,OAAO,cAAc,YAAY,YAAY,CAAC;AAEzD,WAAO,UAAU;AAAA,MACb,SAAS,KAAK,kBAAkB,OAAO;AAAA,MACvC;AAAA,IACJ;AAAA;AAAA;;;AC7BA;AAAA;AAAA,QAAM,EAAE,eAAe;AAKvB,QAAM,sBAAsB,CAAC,EAAE,OAAO,aAAa;AAC/C,YAAM,SAAS,CAAC;AAChB,eAAS,MAAM,GAAG,MAAM,QAAQ,OAAO,GAAG;AACtC,YAAI,QAAQ,GAAG;AACX,iBAAO,OAAO,MAAM,KAAK,EACpB,KAAK,EACL,IAAI,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC;AAAA,QAC9B,OAAO;AACH,iBAAO,OAAO,MAAM,KAAK,EAAE,KAAK,CAAC;AACjC,iBAAO,KAAK,KAAK,CAAC;AAAA,QACtB;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAMA,QAAM,uBAAuB,CAAC,EAAE,OAAO,aAAa;AAChD,YAAM,SAAS,CAAC;AAChB,eAAS,MAAM,GAAG,MAAM,QAAQ,OAAO,GAAG;AACtC,YAAI,QAAQ,GAAG;AACX,iBAAO,OAAO,MAAM,KAAK,EAAE,KAAK,WAAW,IAAI;AAAA,QACnD,OAAO;AACH,iBAAO,OAAO,MAAM,KAAK,EAAE,KAAK,WAAW,IAAI;AAC/C,iBAAO,KAAK,KAAK,WAAW;AAAA,QAChC;AACA,eAAO,GAAG,KAAK,WAAW;AAAA,MAC9B;AACA,aAAO;AAAA,IACX;AAIA,QAAM,eAAe,CAAC,EAAE,OAAO,QAAQ,OAAO,QAC1C,MAAM,MAAM,EACP,KAAK,IAAI,EACT,IAAI,MAAM,MAAM,KAAK,EAAE,KAAK,IAAI,CAAC;AAG1C,QAAM,aAAa,CAAC,EAAE,QAAQ,KAAK,UAAU,OAAO,KAAK,MAAM,GAAG,MAAM,CAAC;AAGzE,QAAM,gBAAgB,CAAC,EAAE,QAAQ,KAAK,UAClC,OACK,MAAM,GAAG,MAAM,CAAC,EAChB,IAAI,CAAC,SAAS,KAAK,MAAM,KAAK,MAAM,CAAC,CAAC,EACtC,OAAO,CAAC,MAAM,SAAS,CAAC,GAAG,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC;AAEtD,WAAO,UAAU;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;AC7DA;AAAA;AAAA,QAAM,EAAE,qBAAqB,yBAAyB;AACtD,QAAM,EAAE,uBAAuB;AAC/B,QAAM,EAAE,aAAa,eAAe;AAEpC,6BAAyB,EAAE,WAAW,WAAW,kBAAkB,2BAA2B;AAE1F,YAAM,SAAS,UAAU,SAAS;AAClC,YAAM,QAAQ,UAAU,SAAS;AACjC,YAAM,gBAAgB,oBAAoB,EAAE,OAAO,OAAO,CAAC;AAC3D,YAAM,kBAAkB,qBAAqB,EAAE,OAAO,OAAO,CAAC;AAE9D,UAAI,YAAY;AAChB,UAAI,kBAAkB,CAAC,GAAG,CAAC;AAG3B,eAAS,MAAM,GAAG,MAAM,QAAQ,OAAO,GAAG;AACtC,iBAAS,MAAM,GAAG,MAAM,OAAO,OAAO,GAAG;AAIrC,gBAAM,kBAAkB,wBAAwB,UAAU,MAAM,IAAI,UAAU,MAAM,EAAE;AAGtF,gBAAM,SAAS;AAAA,YACX,YAAY,cAAc,MAAM,GAAG,OAAO,iBAAiB,GAAG,WAAW,GAAG;AAAA,YAC5E,YAAY,cAAc,KAAK,MAAM,KAAK,iBAAiB,GAAG,WAAW,IAAI;AAAA,YAC7E,YAAY,cAAc,MAAM,GAAG,MAAM,KAAK,iBAAiB,WAAW,QAAQ;AAAA,UACtF;AAGA,gBAAM,EAAE,OAAO,WAAW,cAAc,mBAAmB,QAAQ,SAAS;AAC5E,wBAAc,KAAK,OAAO;AAC1B,0BAAgB,KAAK,OAAO;AAC5B,sBAAY;AACZ,4BAAkB,CAAC,KAAK,GAAG;AAAA,QAC/B;AAAA,MACJ;AAEA,aAAO;AAAA,QACH,gBAAgB;AAAA,QAChB;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,MACpB;AAAA,IACJ;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC9CjB;AAAA;AAAA,QAAM,EAAE,cAAc,eAAe,eAAe;AACpD,QAAM,EAAE,uBAAuB;AAC/B,QAAM,EAAE,aAAa,eAAe;AAKpC,8BAA0B,UAAU;AAChC,UAAI,MAAM;AACV,UAAI,YAAY;AAChB,eAAS,SAAS,GAAG,SAAS,SAAS,QAAQ,UAAU,GAAG;AACxD,YAAI,SAAS,UAAU,KAAK;AACxB,gBAAM,SAAS;AACf,sBAAY;AAAA,QAChB;AAAA,MACJ;AACA,aAAO,EAAE,KAAK,UAAU;AAAA,IAC5B;AAIA,2BAAuB,EAAE,eAAe,KAAK,KAAK,kBAAkB,mBAAmB;AAEnF,YAAM,eAAe,WAAW,EAAE,QAAQ,eAAe,KAAK,IAAI,CAAC;AACnE,YAAM,cAAc,cAAc,EAAE,QAAQ,eAAe,KAAK,IAAI,CAAC;AAGrE,YAAM,EAAE,KAAK,SAAS,WAAW,kBAAkB,iBAAiB,aAAa,QAAQ,CAAC;AAC1F,YAAM,EAAE,KAAK,QAAQ,WAAW,iBAAiB,iBAAiB,YAAY,QAAQ,CAAC;AAOvF,aAAO;AAAA,QACH,YAAY,SAAS,iBAAiB,YAAY,GAAG,WAAW,GAAG;AAAA,QACnE,YAAY,UAAU,iBAAiB,aAAa,GAAG,WAAW,IAAI;AAAA,QACtE,YAAY,cAAc,MAAM,GAAG,MAAM,KAAK,iBAAiB,WAAW,QAAQ;AAAA,MACtF;AAAA,IACJ;AAEA,2BAAuB,EAAE,WAAW,WAAW,kBAAkB,2BAA2B;AAExF,YAAM,SAAS,UAAU,SAAS;AAClC,YAAM,QAAQ,UAAU,SAAS;AACjC,YAAM,gBAAgB,aAAa,EAAE,OAAO,OAAO,CAAC;AACpD,YAAM,kBAAkB,aAAa,EAAE,OAAO,QAAQ,MAAM,WAAW,KAAK,CAAC;AAE7E,UAAI,eAAe;AACnB,UAAI,0BAA0B,CAAC,GAAG,CAAC;AAGnC,eAAS,MAAM,GAAG,MAAM,QAAQ,OAAO,GAAG;AACtC,iBAAS,MAAM,GAAG,MAAM,OAAO,OAAO,GAAG;AAIrC,gBAAM,kBAAkB,wBAAwB,UAAU,MAAM,IAAI,UAAU,MAAM,EAAE;AAGtF,gBAAM,SAAS,cAAc;AAAA,YACzB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACJ,CAAC;AAGD,gBAAM,EAAE,OAAO,WAAW,cAAc,mBAAmB,QAAQ,CAAC;AACpE,wBAAc,KAAK,OAAO;AAC1B,0BAAgB,KAAK,OAAO;AAG5B,cAAI,aAAa,cAAc;AAC3B,2BAAe;AACf,sCAA0B,CAAC,KAAK,GAAG;AAAA,UACvC;AAAA,QACJ;AAAA,MACJ;AAEA,aAAO;AAAA,QACH,gBAAgB;AAAA,QAChB;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,MACpB;AAAA,IACJ;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC1FjB;AAAA;AAAA,QAAM,EAAE,eAAe;AAEvB,QAAM,oBAAoB,CAAC,cAAc,CAAC,cAAc;AACpD,YAAM,WAAW;AAAA,SACZ,WAAW,WAAW,CAAC,EAAE,MAAM,MAAM,KAAK,UAAU,CAAC,KAAK,MAAM,IAAI,KAAK,MAAM,EAAE;AAAA,SACjF,WAAW,OAAO,CAAC,EAAE,MAAM,UAAU,CAAC,WAAW,KAAK,MAAM,EAAE;AAAA,SAC9D,WAAW,MAAM,CAAC,EAAE,MAAM,UAAU,CAAC,KAAK,MAAM,IAAI,SAAS;AAAA,MAClE;AACA,aAAO,SAAS;AAAA,IACpB;AAEA,QAAM,qBAAqB,CAAC,cAAc;AACtC,YAAM,UAAU;AAAA,SACX,WAAW,WAAW,CAAC,CAAC,KAAK,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;AAAA,SACvD,WAAW,OAAO,CAAC,CAAC,KAAK,SAAS,CAAC,KAAK,MAAM,CAAC;AAAA,SAC/C,WAAW,MAAM,CAAC,CAAC,KAAK,SAAS,CAAC,MAAM,GAAG,GAAG;AAAA,MACnD;AACA,aAAO,QAAQ;AAAA,IACnB;AAEA,WAAO,UAAU;AAAA,MACb;AAAA,MACA;AAAA,IACJ;AAAA;AAAA;;;ACvBA;AAAA;AAAA,QAAM,EAAE,mBAAmB,uBAAuB;AAClD,QAAM,EAAE,eAAe;AAEvB,uBAAmB,EAAE,WAAW,WAAW,iBAAiB,gBAAgB,aAAa;AACrF,UAAI,CAAC,KAAK,OAAO;AACjB,YAAM,WAAW,CAAC;AAClB,YAAM,WAAW,CAAC;AAClB,YAAM,iBAAiB,CAAC,CAAC,KAAK,GAAG,CAAC;AAClC,YAAM,WAAW,kBAAkB,SAAS;AAC5C,aAAO,gBAAgB,KAAK,SAAS,WAAW,MAAM;AAClD,cAAM,YAAY,gBAAgB,KAAK;AACvC,cAAM,mBAAmB,SAAS,SAAS;AAC3C,cAAM,CAAC,OAAO,SAAS,iBAAiB,EAAE,MAAM,WAAW,MAAM,WAAW,KAAK,IAAI,CAAC;AACtF,iBAAS,QAAQ,KAAK;AACtB,iBAAS,QAAQ,KAAK;AACtB,cAAM,oBAAoB,mBAAmB,SAAS;AACtD,SAAC,KAAK,GAAG,IAAI,kBAAkB,CAAC,KAAK,GAAG,CAAC;AACzC,uBAAe,KAAK,CAAC,KAAK,GAAG,CAAC;AAAA,MAClC;AACA,aAAO;AAAA,QACH,kBAAkB,SAAS,KAAK,EAAE;AAAA,QAClC,kBAAkB,SAAS,KAAK,EAAE;AAAA,QAClC;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC1BjB;AAAA;AAAA,QAAM,EAAE,eAAe;AACvB,QAAM,YAAY;AAElB,QAAM,iBAAiB,CAAC;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,UACE,CAAC;AAAA,MACH,0BAA0B;AAAA,MAC1B,mBAAmB;AAAA,MACnB,YAAY;AAAA,QACZ,CAAC,MAAO;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,MAAM,YAAY,IAAI,YAAY,IAAI;AAClC,cAAM,EAAE,gBAAgB,eAAe,iBAAiB,mBAAmB,UAAU;AAAA,UACjF;AAAA,UACA;AAAA,UACA,kBAAkB,KAAK;AAAA,UACvB,yBAAyB,KAAK;AAAA,QAClC,CAAC;AACD,cAAM,EAAE,kBAAkB,kBAAkB,mBAAmB,UAAU;AAAA,UACrE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,WAAW,KAAK;AAAA,QACpB,CAAC;AACD,eAAO;AAAA,UACH,OAAO;AAAA,UACP,mBAAmB,CAAC,WAAW,SAAS;AAAA,UACxC,kBAAkB,CAAC,kBAAkB,gBAAgB;AAAA,UACrD;AAAA,UACA;AAAA,UACA;AAAA,UACA,WAAW,GAAG;AAAA,EAAqB;AAAA,QACvC;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO,UAAU;AAAA;AAAA;;;AC3CjB;AAAA;AAAA,QAAM,EAAE,YAAY;AAEpB,QAAM,cAAc;AACpB,QAAM,cAAc;AACpB,QAAM,iBAAiB;AAEvB,WAAO,UAAU;AAAA,MACb,WAAW,eAAe;AAAA,QACtB,WAAW;AAAA,QACX,gCAAgC,CAAC,OAAO,UAAW,UAAU,QAAQ,IAAI;AAAA,QACzE,yBAAyB,MAAM;AAAA,QAC/B,kBAAkB;AAAA,MACtB,CAAC;AAAA,MACD,WAAW,eAAe;AAAA,QACtB,WAAW;AAAA,QACX,gCAAgC,CAAC,OAAO,UAAW,UAAU,QAAQ,IAAI;AAAA,QACzE,yBAAyB;AAAA,QACzB,kBAAkB;AAAA,MACtB,CAAC;AAAA,IACL;AAAA;AAAA;",
  "names": []
}
